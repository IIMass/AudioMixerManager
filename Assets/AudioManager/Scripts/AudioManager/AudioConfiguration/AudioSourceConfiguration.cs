using UnityEngine;

namespace Massitao.AudioManager
{
    [System.Serializable]
    public class AudioSourceConfiguration
    {
        #region Audio Mixer Configuration
        [Header("Audio Mixer / Effects Configuration")]
        [Tooltip("Bypass effects (Applied from filter components or global listener filters).")]
        [SerializeField] private bool bypassEffects = false;

        [Tooltip("When set global effects on the AudioListener will not be applied to the audio signal generated by the AudioSource. Does not apply if the AudioSource is playing into a mixer group.")]
        [SerializeField] private bool bypassListenerEffects = false;

        [Tooltip("When set, doesn't route the signal from an AudioSource into the global reverb associated with reverb zones.")]
        [SerializeField] private bool bypassReverbZones = false;

        public bool GetBypassEffects()
        {
            return bypassEffects;
        }
        public void SetBypassEffects(bool value)
        {
            bypassEffects = value;
        }

        public bool GetBypassListenerEffects()
        {
            return bypassListenerEffects;
        }
        public void SetBypassListenerEffects(bool value)
        {
            bypassListenerEffects = value;
        }

        public bool GetBypassReverbZones()
        {
            return bypassReverbZones;
        }
        public void SetBypassReverbZones(bool value)
        {
            bypassReverbZones = value;
        }
        #endregion

        #region Audio Source Configuration
        [Header("Audio Source Configuration")]
        #region Priority
        [Tooltip("Determines the priority of this audio source among all the ones that coexist in the scene. (Priority: 0 = most important. 256 = least important. Default = 128.). Use 0 for music tracks to avoid it getting occasionally swapped out.")]
        [SerializeField] [Range(0, 256)] private int priority = 128;

        public int GetPriority()
        {
            return priority;
        }
        public void SetPriority(int value)
        {
            priority = Mathf.Clamp(value, 0, 256);
        }
        #endregion

        [Space(10)]

        #region Volume
        [Tooltip("Select fixed volume or from value range.")]
        [SerializeField] private bool selectFromVolumeRange = false;

        [Tooltip("Sets the overall volume of the sound.")]
        [SerializeField] [Range(0f, 1f)] private float volume = 1f;

        [Tooltip("Sets the minimum value of the Volume Range.")]
        [SerializeField] [Range(0f, 1f)] private float minimumVolumeRange = 1f;

        [Tooltip("Sets the maximum value of the Volume Range.")]
        [SerializeField] [Range(0f, 1f)] private float maximumVolumeRange = 1f;

        public void SetVolumeSelectionMode(bool selectFromRange)
        {
            selectFromVolumeRange = selectFromRange;
        }

        public float GetVolume()
        {
            if (selectFromVolumeRange)
            {
                if (maximumVolumeRange < minimumVolumeRange)
                {
                    maximumVolumeRange = minimumVolumeRange;
                }

                return Random.Range(minimumVolumeRange, maximumVolumeRange);
            }
            else
            {
                return volume;
            }
        }
        public void SetFixedVolume(float value)
        {
            volume = Mathf.Clamp01(value);
        }
        public void SetVolumeRange(float minimum, float maximum)
        {
            SetMinimumVolumeRange(minimum);
            SetMaximumVolumeRange(maximum);
        }
        public void SetMinimumVolumeRange(float value)
        {
            minimumVolumeRange = Mathf.Clamp01(value);

            if (minimumVolumeRange > maximumVolumeRange)
            {
                maximumVolumeRange = minimumVolumeRange;
            }
        }
        public void SetMaximumVolumeRange(float value)
        {
            maximumVolumeRange = Mathf.Clamp01(value);

            if (maximumVolumeRange < minimumVolumeRange)
            {
                minimumVolumeRange = maximumVolumeRange;
            }
        }
        #endregion

        [Space(10)]

        #region Pitch
        [Tooltip("Select fixed pitch or from value range.")]
        [SerializeField] private bool selectFromPitchRange = false;

        [Tooltip("Set the frequency of the sound. Use this to slow down or speed up the sound.")]
        [SerializeField] [Range(-3f, 3f)] public float pitch = 1f;

        [Tooltip("Sets the minimum value of the Volume Range.")]
        [SerializeField] [Range(-3f, 3f)] private float minimumPitchRange = 1f;

        [Tooltip("Sets the maximum value of the Volume Range.")]
        [SerializeField] [Range(-3f, 3f)] private float maximumPitchRange = 1f;

        public void SetPitchSelectionMode(bool selectFromRange)
        {
            selectFromPitchRange = selectFromRange;
        }

        public float GetPitch()
        {
            if (selectFromPitchRange)
            {
                if (maximumPitchRange < minimumPitchRange)
                {
                    maximumPitchRange = minimumPitchRange;
                }

                return Random.Range(minimumPitchRange, maximumPitchRange);
            }
            else
            {
                return pitch;
            }
        }
        public void SetFixedPitch(float value)
        {
            pitch = Mathf.Clamp(value, -3f, 3f);
        }
        public void SetPitchRange(float minimum, float maximum)
        {
            SetMinimumPitchRange(minimum);
            SetMaximumPitchRange(maximum);
        }
        public void SetMinimumPitchRange(float value)
        {
            minimumPitchRange = Mathf.Clamp(value, -3f, 3f);

            if (minimumPitchRange > maximumPitchRange)
            {
                maximumPitchRange = minimumPitchRange;
            }
        }
        public void SetMaximumPitchRange(float value)
        {
            maximumPitchRange = Mathf.Clamp(value, -3f, 3f);

            if (maximumPitchRange < minimumPitchRange)
            {
                minimumPitchRange = maximumPitchRange;
            }
        }
        #endregion

        [Space(10)]

        #region Stereo Pan
        [Tooltip("This only applies to AudioClips that are Mono or Stereo. Mono sounds will be panned at constant power left and right. Stereo sounds will have each left/right value faded up and down according to the specified pan value. -1.0 is left, 1.0 is right.")]
        [SerializeField] [Range(-1f, 1f)] private float stereoPan = 0f;

        public float GetStereoPan()
        {
            return stereoPan;
        }
        public void SetStereoPan(float value)
        {
            stereoPan = Mathf.Clamp(value, -1f, 1f);
        }
        #endregion

        #region Spatial Blend
        [Tooltip("Sets how much this AudioSource is treated as a 3D source. 3D sources are affected by spatial position and spread. If 3D Pan Level is 0, all spatial attenuation is ignored. 0.0 makes the sound full 2D, 1.0 makes it full 3D.")]
        [SerializeField] [Range(0f, 1f)] private float spatialBlend = 0f;

        public float GetSpatialBlend()
        {
            return spatialBlend;
        }
        public void SetSpatialBlend(float value)
        {
            spatialBlend = Mathf.Clamp01(value);
        }
        #endregion

        #region Reverb Mix
        [Tooltip("Sets how much of the signal this AudioSource is mixing into the global reverb associated with the zones. [0, 1] is a linear range (like volume) while [1, 1.1] lets you boost the reverb mix by 10 dB.")]
        [SerializeField] [Range(0f, 1.1f)] private float reverbMix = 1f;

        public float GetReverbMix()
        {
            return reverbMix;
        }
        public void SetReverbMix(float value)
        {
            reverbMix = Mathf.Clamp(value, 0f, 1.1f);
        }
        #endregion

        #region Audio Source 3D Settings
        [Header("Audio Source 3D Settings")]
        [SerializeField] private AudioSource3DSoundSettings settings3D = new AudioSource3DSoundSettings();

        public float GetDopplerLevel()
        {
            return settings3D.dopplerLevel;
        }
        public float GetSpread()
        {
            return settings3D.spread;
        }
        public AudioRolloffMode GetVolumeRolloff()
        {
            return settings3D.volumeRolloff;
        }
        public float GetMinimumDistance()
        {
            return settings3D.minDistance;
        }
        public float GetMaximumDistance()
        {
            return settings3D.maxDistance;
        }

        public bool SetAudioSourceCurves (AudioSource sourceToChangeCurve)
        {
            bool rollOffSuccess = false;

            rollOffSuccess = SetRolloffCurve(sourceToChangeCurve);
            SetSpatialBlendCurve(sourceToChangeCurve);
            SetSpreadCurve(sourceToChangeCurve);
            SetReverbMixCurve(sourceToChangeCurve);

            return rollOffSuccess;
        }
        private bool SetRolloffCurve     (AudioSource sourceToChangeCurve)
        {
            sourceToChangeCurve.rolloffMode = settings3D.volumeRolloff;

            if (sourceToChangeCurve.rolloffMode == AudioRolloffMode.Custom)
            {
                if (settings3D.rolloffCurve != null && settings3D.rolloffCurve.keys.Length > 1)
                {
                    sourceToChangeCurve.SetCustomCurve(AudioSourceCurveType.CustomRolloff, settings3D.rolloffCurve);
                    return true;
                }
                else
                {
                    sourceToChangeCurve.rolloffMode = AudioRolloffMode.Logarithmic;
                    return false;
                }
            }

            return true;
        }
        private void SetSpatialBlendCurve(AudioSource sourceToChangeCurve)
        {
            if (settings3D.spatialBlendCurve != null && settings3D.spatialBlendCurve.keys.Length > 0)
            {
                sourceToChangeCurve.SetCustomCurve(AudioSourceCurveType.SpatialBlend, settings3D.spatialBlendCurve);
            }
        }
        private void SetSpreadCurve      (AudioSource sourceToChangeCurve)
        {
            if (settings3D.spreadCurve != null && settings3D.spreadCurve.keys.Length > 0)
            {
                sourceToChangeCurve.SetCustomCurve(AudioSourceCurveType.Spread, settings3D.spreadCurve);
            }
        }
        private void SetReverbMixCurve   (AudioSource sourceToChangeCurve)
        {
            if (settings3D.reverbMixCurve != null && settings3D.reverbMixCurve.keys.Length > 0)
            {
                sourceToChangeCurve.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, settings3D.reverbMixCurve);
            }
        }

        public void ResetAudioSourceCurves()
        {
            settings3D.rolloffCurve.keys = new Keyframe[0];
            settings3D.spatialBlendCurve.keys = new Keyframe[0];
            settings3D.spreadCurve.keys = new Keyframe[0];
            settings3D.reverbMixCurve.keys = new Keyframe[0];

            Debug.Log("Audio Curves have been reseted. Actual curves are empty and you are free to start over again. Select another Object and click again on this Object.");
        }
        #endregion
        #endregion
    }

    [System.Serializable]
    public class AudioSource3DSoundSettings
    {
        [Tooltip("Specifies how much the pitch is changed based on the relative velocity between AudioListener and AudioSource.")]
        [Range(0f, 5f)] public float dopplerLevel = 1f;

        [Tooltip("Sets the spread of a 3D sound in speaker space.")]
        [Range(0f, 360f)] public float spread = 0f;

        [Tooltip("Sets/Gets how the AudioSource attenuates over distance.")]
        public AudioRolloffMode volumeRolloff = AudioRolloffMode.Logarithmic;

        [Tooltip("Within the Min distance the AudioSource will cease to grow louder in volume.")]
        [Min(0f)] public float minDistance = 1f;

        [Tooltip("// (Logarithmic rolloff) MaxDistance is the distance a sound stops attenuating at.")]
        [Min(0f)] public float maxDistance = 500f;

        [Space(10)]

        [Header("AudioSource Curves | Only if you want custom curves")]
        [Tooltip("Custom Rolloff. Minimum distance will be overridden.")]
        public AnimationCurve rolloffCurve;

        [Tooltip("Custom Spatial Blend. Spatial Blend will be overridden.")]
        public AnimationCurve spatialBlendCurve;

        [Tooltip("Custom Spread. Spread will be overridden.")]
        public AnimationCurve spreadCurve;

        [Tooltip("Custom Reverb Mix. Reverb Mix will be overridden.")]
        public AnimationCurve reverbMixCurve;
    }
}